#include "interpreter.h"

#include <inttypes.h>
#include<stdlib.h>
#include<stddef.h>
/*
void print_bpf_state(struct bpf_state* st){
  printf("pc= %" PRIu64 "\n", (uint64_t) (*st).state_pc);
  printf("flag= %d\n", (*st).bpf_flag);
  for(int i = 0; i < 11; i++){
    printf("R%d",i);
    printf("= %" PRIu64 ";", (uint64_t) (*st).regsmap[i]);
  }
  printf("\n");
}*/

static unsigned int eval_pc (struct bpf_state* st) {
  return (*st).state_pc;
}

static void upd_pc(struct bpf_state* st, unsigned int pc) {
  (*st).state_pc = pc;
  return ;
}
static void upd_pc_incr(struct bpf_state* st) {
  (*st).state_pc = (*st).state_pc+1;
  return ;
}


static unsigned long long eval_reg(struct bpf_state* st, unsigned int i){
  return (*st).regsmap[i];
}

static void upd_reg (struct bpf_state* st, unsigned int i, unsigned long long v){
  (*st).regsmap[i] = v;
  return ;
}

static int eval_flag(struct bpf_state* st){
  return (*st).bpf_flag;
}

static void upd_flag(struct bpf_state* st, int f){
  (*st).bpf_flag = f;
  return ;
}

static unsigned int eval_mem_num(struct bpf_state* st){
  return (*st).mrs_num;
}

static struct memory_region *eval_mem_regions(struct bpf_state* st){
  return (*st).mrs;
}

/*
void add_mem_region(struct bpf_state* st, struct memory_region* mr){
  (*st).mrs[(*st).mem_num] = *mr;
  (*st).mem_num += 1;
  return ;
}

void add_mem_region_ctx(struct bpf_state* st, struct memory_region* mr){
  (*st).mrs[0] = *mr;
  (*st).mem_num = 1;
  return ;
}*/

static unsigned long long load_mem(struct bpf_state* st, unsigned int chunk, unsigned int addr){
  /*if (addr == 0U) {
    (*st).bpf_flag = BPF_ILLEGAL_MEM; return ;
  }
  else{*/
    switch (chunk) {
      case 1: return *(unsigned char *) (uintptr_t) addr;
      case 2: return *(unsigned short *) (uintptr_t) addr;
      case 4: return *(unsigned int *) (uintptr_t) addr;
      case 8: return *(unsigned long long *) (uintptr_t) addr;
      default: /*printf ("load:addr = %" PRIu64 "\n", v); (*st).bpf_flag = BPF_ILLEGAL_MEM;*/ return 0LLU;
    }
  //}
}

static void store_mem_reg(struct bpf_state* st, unsigned int chunk, unsigned int addr, unsigned long long v){
  /*if (addr == 0U) {
    (*st).bpf_flag = BPF_ILLEGAL_MEM; return ;
  }
  else{*/
    switch (chunk) {
      case 1: *(unsigned char *) (uintptr_t) addr = v; return ;
      case 2: *(unsigned short *) (uintptr_t) addr = v; return ;
      case 4: *(unsigned int *) (uintptr_t) addr = v; return ;
      case 8: *(unsigned long long *) (uintptr_t) addr = v; return ;
      default: /*printf ("store_reg:addr = %" PRIu64 "\n", addr);*/ (*st).bpf_flag = BPF_ILLEGAL_MEM; return ;
    }
  //}
}

static void store_mem_imm(struct bpf_state* st, unsigned int chunk, unsigned int addr, int v){
  /*if (addr == 0U) {
    (*st).bpf_flag = BPF_ILLEGAL_MEM; return ;
  }
  else{*/
    switch (chunk) {
      case 1: *(unsigned char *) (uintptr_t) addr = v; return ;
      case 2: *(unsigned short *) (uintptr_t) addr = v; return ;
      case 4: *(unsigned int *) (uintptr_t) addr = v; return ;
      case 8: *(unsigned long long *) (uintptr_t) addr = v; return ;
      default: /*printf ("store_imm:addr = %" PRIu64 "\n", addr);*/ (*st).bpf_flag = BPF_ILLEGAL_MEM; return ;
    }
  //}
}

/*******************below code are automatically generated by dx (after repatch) ***************************/
